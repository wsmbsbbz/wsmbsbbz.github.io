<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MIT6.824 Raft-Log实验记录 | wsmbsbbz.github.io</title><meta name=keywords content><meta name=description content="Lab用时：14.5小时
实验分析 本实验要让Raft在在上一个Leader Election的基础上，对clients的请求做出响应，接受clients的command，并在command被安全committed后响应clients。
Raft paper中的Figure 2仍然是最有价值的参照：
我们需要实现：
leader要能够把Start方法的command参数append到自身的log中，然后通过AppendEntries RPC把log发送给别的peers。 followers不能仅把AppendEntries RPC当作heartbeat，还要把RPC参数和自己的log比较，并在恰当的时机修改自身的log相关的字段，并返回Figure 2要求的reply。 注意上一个Leader Election lab中并没有要求实现paper中5.4.1章节的Election Restriction，我们还需要在RequestVote RPC handler中实现。 结构设计 这里只写相较于Leader Election需要增添或更改的部分。
logEntry 除了必须的Term和Command字段外，我也把log的Index写入了logEntry中，这样代码会更加简洁，详见我后面踩坑部分的解释。
type logEntry struct { Index int Term int Command interface{} } Raft 除了Leader Election中已经实现的字段外，对于这个lab，我加上了这些字段：
type Raft struct { log []logEntry // 自身的log条目 commitIndex int // 最近一次commit的log的index，要保证这个字段只能单增 sequreCommit int // 可以安全commit的log的index // paper中nextIndex字段我没有用到，实测只需要matchIndex就足够了，维护nextIndex的状态反而会使代码逻辑更加复杂 matchIndex []int // 长度为peers的数量，表明当前peer和别的peers匹配成功的最大log index applyCh chan ApplyMsg // 每当commitIndex递增时，就应该向applyCh发送一个ApplyMsg，以供Tester测试 } RequestVoteArgs Leader Election只需要Term和CandidateId，若要实现5."><meta name=author content="wsmbsbbz"><link rel=canonical href=https://wsmbsbbz.github.io/posts/mit6.824-lab2b-log/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wsmbsbbz.github.io/img/logo.ico><link rel=icon type=image/png sizes=16x16 href=https://wsmbsbbz.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wsmbsbbz.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wsmbsbbz.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wsmbsbbz.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="MIT6.824 Raft-Log实验记录"><meta property="og:description" content="Lab用时：14.5小时
实验分析 本实验要让Raft在在上一个Leader Election的基础上，对clients的请求做出响应，接受clients的command，并在command被安全committed后响应clients。
Raft paper中的Figure 2仍然是最有价值的参照：
我们需要实现：
leader要能够把Start方法的command参数append到自身的log中，然后通过AppendEntries RPC把log发送给别的peers。 followers不能仅把AppendEntries RPC当作heartbeat，还要把RPC参数和自己的log比较，并在恰当的时机修改自身的log相关的字段，并返回Figure 2要求的reply。 注意上一个Leader Election lab中并没有要求实现paper中5.4.1章节的Election Restriction，我们还需要在RequestVote RPC handler中实现。 结构设计 这里只写相较于Leader Election需要增添或更改的部分。
logEntry 除了必须的Term和Command字段外，我也把log的Index写入了logEntry中，这样代码会更加简洁，详见我后面踩坑部分的解释。
type logEntry struct { Index int Term int Command interface{} } Raft 除了Leader Election中已经实现的字段外，对于这个lab，我加上了这些字段：
type Raft struct { log []logEntry // 自身的log条目 commitIndex int // 最近一次commit的log的index，要保证这个字段只能单增 sequreCommit int // 可以安全commit的log的index // paper中nextIndex字段我没有用到，实测只需要matchIndex就足够了，维护nextIndex的状态反而会使代码逻辑更加复杂 matchIndex []int // 长度为peers的数量，表明当前peer和别的peers匹配成功的最大log index applyCh chan ApplyMsg // 每当commitIndex递增时，就应该向applyCh发送一个ApplyMsg，以供Tester测试 } RequestVoteArgs Leader Election只需要Term和CandidateId，若要实现5."><meta property="og:type" content="article"><meta property="og:url" content="https://wsmbsbbz.github.io/posts/mit6.824-lab2b-log/"><meta property="og:image" content="https://wsmbsbbz.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-17T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wsmbsbbz.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MIT6.824 Raft-Log实验记录"><meta name=twitter:description content="Lab用时：14.5小时
实验分析 本实验要让Raft在在上一个Leader Election的基础上，对clients的请求做出响应，接受clients的command，并在command被安全committed后响应clients。
Raft paper中的Figure 2仍然是最有价值的参照：
我们需要实现：
leader要能够把Start方法的command参数append到自身的log中，然后通过AppendEntries RPC把log发送给别的peers。 followers不能仅把AppendEntries RPC当作heartbeat，还要把RPC参数和自己的log比较，并在恰当的时机修改自身的log相关的字段，并返回Figure 2要求的reply。 注意上一个Leader Election lab中并没有要求实现paper中5.4.1章节的Election Restriction，我们还需要在RequestVote RPC handler中实现。 结构设计 这里只写相较于Leader Election需要增添或更改的部分。
logEntry 除了必须的Term和Command字段外，我也把log的Index写入了logEntry中，这样代码会更加简洁，详见我后面踩坑部分的解释。
type logEntry struct { Index int Term int Command interface{} } Raft 除了Leader Election中已经实现的字段外，对于这个lab，我加上了这些字段：
type Raft struct { log []logEntry // 自身的log条目 commitIndex int // 最近一次commit的log的index，要保证这个字段只能单增 sequreCommit int // 可以安全commit的log的index // paper中nextIndex字段我没有用到，实测只需要matchIndex就足够了，维护nextIndex的状态反而会使代码逻辑更加复杂 matchIndex []int // 长度为peers的数量，表明当前peer和别的peers匹配成功的最大log index applyCh chan ApplyMsg // 每当commitIndex递增时，就应该向applyCh发送一个ApplyMsg，以供Tester测试 } RequestVoteArgs Leader Election只需要Term和CandidateId，若要实现5."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://wsmbsbbz.github.io/posts/"},{"@type":"ListItem","position":3,"name":"MIT6.824 Raft-Log实验记录","item":"https://wsmbsbbz.github.io/posts/mit6.824-lab2b-log/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIT6.824 Raft-Log实验记录","name":"MIT6.824 Raft-Log实验记录","description":"Lab用时：14.5小时\n实验分析 本实验要让Raft在在上一个Leader Election的基础上，对clients的请求做出响应，接受clients的command，并在command被安全committed后响应clients。\nRaft paper中的Figure 2仍然是最有价值的参照：\n我们需要实现：\nleader要能够把Start方法的command参数append到自身的log中，然后通过AppendEntries RPC把log发送给别的peers。 followers不能仅把AppendEntries RPC当作heartbeat，还要把RPC参数和自己的log比较，并在恰当的时机修改自身的log相关的字段，并返回Figure 2要求的reply。 注意上一个Leader Election lab中并没有要求实现paper中5.4.1章节的Election Restriction，我们还需要在RequestVote RPC handler中实现。 结构设计 这里只写相较于Leader Election需要增添或更改的部分。\nlogEntry 除了必须的Term和Command字段外，我也把log的Index写入了logEntry中，这样代码会更加简洁，详见我后面踩坑部分的解释。\ntype logEntry struct { Index int Term int Command interface{} } Raft 除了Leader Election中已经实现的字段外，对于这个lab，我加上了这些字段：\ntype Raft struct { log []logEntry // 自身的log条目 commitIndex int // 最近一次commit的log的index，要保证这个字段只能单增 sequreCommit int // 可以安全commit的log的index // paper中nextIndex字段我没有用到，实测只需要matchIndex就足够了，维护nextIndex的状态反而会使代码逻辑更加复杂 matchIndex []int // 长度为peers的数量，表明当前peer和别的peers匹配成功的最大log index applyCh chan ApplyMsg // 每当commitIndex递增时，就应该向applyCh发送一个ApplyMsg，以供Tester测试 } RequestVoteArgs Leader Election只需要Term和CandidateId，若要实现5.","keywords":[],"articleBody":" Lab用时：14.5小时\n实验分析 本实验要让Raft在在上一个Leader Election的基础上，对clients的请求做出响应，接受clients的command，并在command被安全committed后响应clients。\nRaft paper中的Figure 2仍然是最有价值的参照：\n我们需要实现：\nleader要能够把Start方法的command参数append到自身的log中，然后通过AppendEntries RPC把log发送给别的peers。 followers不能仅把AppendEntries RPC当作heartbeat，还要把RPC参数和自己的log比较，并在恰当的时机修改自身的log相关的字段，并返回Figure 2要求的reply。 注意上一个Leader Election lab中并没有要求实现paper中5.4.1章节的Election Restriction，我们还需要在RequestVote RPC handler中实现。 结构设计 这里只写相较于Leader Election需要增添或更改的部分。\nlogEntry 除了必须的Term和Command字段外，我也把log的Index写入了logEntry中，这样代码会更加简洁，详见我后面踩坑部分的解释。\ntype logEntry struct { Index int Term int Command interface{} } Raft 除了Leader Election中已经实现的字段外，对于这个lab，我加上了这些字段：\ntype Raft struct { log []logEntry // 自身的log条目 commitIndex int // 最近一次commit的log的index，要保证这个字段只能单增 sequreCommit int // 可以安全commit的log的index // paper中nextIndex字段我没有用到，实测只需要matchIndex就足够了，维护nextIndex的状态反而会使代码逻辑更加复杂 matchIndex []int // 长度为peers的数量，表明当前peer和别的peers匹配成功的最大log index applyCh chan ApplyMsg // 每当commitIndex递增时，就应该向applyCh发送一个ApplyMsg，以供Tester测试 } RequestVoteArgs Leader Election只需要Term和CandidateId，若要实现5.4.1的Election Restriction，还需要加上LastLogIndex和LastLogTerm两个字段。\ntype RequestVoteArgs struct { Term int CandidateId int LastLogIndex int // 发送RequestVote的peer的最新的log的index LastLogTerm int // 发送RequestVote的peer的最新的log的term } AppendEntriesArgs type AppendEntriesArgs struct { Term int LeaderId int PrevLogIndex int // AppendEntries假定的此peer拥有的最新的log的index PrevLogTerm int // AppendEntries假定的此peer拥有的最新的log的term Entries []logEntry // 需要append的logEntry LeaderCommit int // RPC发起者的secureCommit的 } 逻辑设计 这一部分的lab涉及很多log的更新，debug难度比Leader Election难很多。而且需要精心设计、分析一些机制的实现思路，否则非常容易栽到某写edge cases，然后坠入debug的深渊一去不返……如果能选定合适的实现思路，那代码逻辑并不难写，在Leader Election的代码基础上修修补补即可。\ncommitter 效仿之前Leader Election的ticker()和beater()，我又写了一个committer()，用来递增commitIndex并向applyCh发送ApplyMsg。对于leader，还要更新secureCommit的值，这里我参考了别人的实现思路，对matchIndex排序，把中间值设定为secureCommit。也原子化绑定了commitIndex和发送ApplyMsg操作、保证了commitIndex是单增的。\nfunc (rf *Raft) committer() { for rf.killed() == false { rf.mu.Lock() if rf.state == Leader { n := len(rf.peers) commitNums := make([]int, n) copy(commitNums, rf.matchIndex) sort.Ints(commitNums) rf.commitIndex = rf.secureCommit rf.secureCommit = commitNums[n/2] } for rf.commitIndex \u003c rf.secureCommit { rf.commitIndex++ applyMsg := ApplyMsg{ CommandValid: true, Command: rf.log[rf.commitIndex].Command, CommandIndex: rf.log[rf.commitIndex].Index, } rf.applyCh \u003c- applyMsg } rf.mu.Unlock() time.Sleep(timerLoop) } } Start Start()方法负责把tester/clients的command添加到自身的log中，然后直接return。\nfunc (rf *Raft) Start(command interface{}) (int, int, bool) { // Your code here (2B). rf.mu.Lock() index, term, isLeader := rf.log[len(rf.log)-1].Index+1, rf.currentTerm, rf.state == Leader if rf.state != Leader { rf.mu.Unlock() return index, term, isLeader } log := logEntry{rf.log[len(rf.log)-1].Index + 1, rf.currentTerm, command} rf.log = append(rf.log, log) rf.mu.Unlock() return index, term, isLeader } 这个时候读者可能会意识到一个问题，就是我们什么时候向peers发送包含log信息的AppendEntries RPC呢？\nStudents’ Guide to Raft中明确说明了，heartbeat和一般的含有log信息的AppendEntries不仅仅是都通过AppendEntries RPC来调用，同样需要完全按照AppendEntries RPC handler的流程对待。\nMany of our students assumed that heartbeats were somehow “special”; that when a peer receives a heartbeat, it should treat it differently from a non-heartbeat AppendEntries RPC. In particular, many would simply reset their election timer when they received a heartbeat, and then return success, without performing any of the checks specified in Figure 2. This is extremely dangerous.\n但我没有按照guide把heartbeat的log长度设为0，而是做的更极端了一点：直接让heartbeat也能带有logEntry。这样能在candidate成为leader之后，立即把自身的所有log发送给别的peers，然后根据响应更新matchIndex，再之后网络连接稳定的情况下，followers和leader的log能保持一致，此时的heartbeat中不包含logEntry，AppendEntries RPC handler也就不会更新自身的log了。实现的关键在于sendHeartbeat和AppendEntries。\nsendHeartbeat sendHeartbeat()根据matchIndex对所有peers(包括leader自身)发送带有合适logEntry的AppendEntries RPC请求，并在reply.Success == true时递增matchIndex。\n注意这里不能直接使用matchIndex[i] += len(args.Entries)，否则若出现RPC交错的情况，matchIndex的值可能会减少，就不符合matchIndex的单增性质；也不能直接用matchIndex[i] = args.PrevLogIndex+len(args.Entries)，在RPC交错的时候也可能导致matchIndex的值减少（不过在lab测试中没有测试这种情况）。\n注：我这里所说的RPC交错指的是：先通过RPC调用发出请求A再发出B，但是先收到B的响应再收到A的响应。但我们不能用lock序列化发送RPC并等待接受响应，这样性能损耗太大，所以只能通过类似的单增性质来保证过时的RPC响应不影响程序的正确性。\n// NOTE: protocol: 必须已经hold rf.mu,再调用此方法 func (rf *Raft) sendHeartbeats() { for i := range rf.peers { args := \u0026AppendEntriesArgs{ Term: rf.currentTerm, LeaderId: rf.me, PrevLogIndex: rf.matchIndex[i], PrevLogTerm: rf.log[rf.matchIndex[i]].Term, Entries: rf.log[rf.matchIndex[i]+1:], LeaderCommit: rf.secureCommit, } reply := \u0026AppendEntriesReply{} go func(i int) { rf.sendAppendEntries(i, args, reply) rf.mu.Lock() if reply.Term \u003e rf.currentTerm { rf.coverTerm(reply.Term) } if reply.Success { rf.matchIndex[i] = max(rf.matchIndex[i], args.PrevLogIndex+len(args.Entries)) } rf.mu.Unlock() }(i) } } AppendEntries func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { rf.mu.Lock() defer func() { reply.Term = rf.currentTerm rf.mu.Unlock() }() // Rules for All Servers: // NOTE: rule 1 has been implemented in committer // 2. if args.Term \u003e rf.currentTerm, convert to follower if args.Term \u003e rf.currentTerm { rf.coverTerm(args.Term) } // Receiver implementation: // 1. reply false if term \u003c currentTerm if args.Term \u003c rf.currentTerm { reply.Success = false return } // 2. reply false if log doesn't contain an entry at prevLogIndex whose term // matches prevLogTerm lastLog := rf.log[len(rf.log)-1] if args.PrevLogIndex \u003e lastLog.Index || rf.log[args.PrevLogIndex].Term != args.PrevLogTerm { reply.Success = false return } // 3. If an existing entry conflicts with a new one (same index but different // terms), delete the existing entry and all that follow it ($5.3) var i int for i = 0; i \u003c len(args.Entries) \u0026\u0026 (args.PrevLogIndex+1+i) \u003c len(rf.log); i++ { if !checkLogEqual(rf.log[args.PrevLogIndex+1+i], args.Entries[i]) { rf.log = rf.log[:args.PrevLogIndex+1+i] break } } // 4. Append any new entries not already in the log rf.log = append(rf.log, args.Entries[i:]...) // 5. If leaderCommit \u003e commitIndex, set commitIndex = min( // leaderCommit, index of last new entry) rf.secureCommit = min(args.LeaderCommit, rf.log[len(rf.log)-1].Index) reply.Success = true rf.tickerReset() } AppendEntries按照Figure 2的要求来即可。\n踩坑 这次lab踩坑较多：\n一开始我的logEntry结构中没有设定Index字段，是用数组下标来表示index的，就有很多很难处理的边界情况。后来加了Index字段之后，也在Raft启动时直接增添一个Index为0的空log，保证log的Index和数组的下标相同，这应该也能简化后面log impaction lab的代码。 一开始没有想到专门设一个committer的思路，也没能把heartbeat和带logEntry的AppendEntries完全画等号，导致代码逻辑冗杂混乱。 虽然Students’ Guide to Raft中明确说明了nextIndex和matchIndex是两个不同的状态，不能简单使用matchIndex + 1来表示nextIndex，但我实际发现在我的代码版本中nextIndex字段就没有存在的必要，只需要保证每个peer的matchIndex中每个位置都从0开始单增，就足以保证Raft能正常推进。不过缺点是在leader更替之后，新leader还要让matchIndex从0开始递增，会导致RPC参数体积过大，有较大网络流量。在完成log impaction lab之后应该能有效解决这个问题。 我本来在发送和接受RPC响应的地方写了很多检查state状态有没有改变的代码，想借此处理RPC发送期间state改变的情况（比如：leader在发送AppendEntries请求后退位，成为follower，那就不应该处理RPC的响应了）。但paper和lab要求中没有说要实现这些，实际上也只需保证某些字段的更新限制(如单增)就能保证RPC处理的安全性。 Start方法应该尽快响应，在goroutine中处理log replication、commit的逻辑。不需要在Start中主动发起AppendEntries RPC请求，等待后台长时间运行的beater和committer处理即可。 起初在sendHeartbeat或者AppendEntries中写了一些检测RPC请求是否是heartbeat的代码，后来才意识到可以让这两个请求完全等价。 起初我用sync.Cond计算AppendEntries RPC响应的successCnt，在successCnt超过半数时commit。后来参考别人的思路改用排序commitIndex取中值的写法，很大程度上简化了代码逻辑，在通常仅有几台的Raft集群中也几乎没有什么排序代价。 Raft的paper字字珠玑，我一开始没有理解log是否up-to-date的含意：需要检测args.LastLogTerm \u003c curLastLogTerm和args.LastLogTerm == curLastLogTerm \u0026\u0026 args.LastLogIndex \u003c curLastLogIndex两种情况。 在发送和接受处理RPC时，没必要对leader自身区别对待，即leader可以用尽可能少的特权，只更新维持Raft状态推进的必要状态，其余的状态通过自己对自己发送RPC来更新，能简化代码。 优化空间 还真不知道。\n总结 最终的成品代码我比较满意，ticker、beater、committer这三个长时间在goroutine中运行的三个方法是非常好的一层抽象：Raft状态机在Start方法中更新自己的log状态，ticker更新state状态，beater联系别的peers更新他们的log状态，committer更新自己的commitIndex状态，相互之间有很清晰的分工和隔离，整体程序框架和代码逻辑都很清晰。\n收获 有了上次Leader Election的教训，这次没有在lock上再翻车，对lock的运用要熟练很多。\n这个lab不仅要处理本地程序的代码并发，还要处理网络中RPC请求、响应的并发。而对RPC加lock绝对是得不偿失的，于是通过对属性的更新设限制来保证RPC并发的安全性。这确实是我以前从未见过的处理方式，涨见识了。\n教训 感觉这次写代码还是有点操之过急了，debug了非常久，下个lab可以尝试把整个完整方案从头到尾写完整，再分析每一个步骤可能带来的问题，仔细分析多个替代方案之后再开始写代码。\n这好几次写lab都是写好代码后跑不过测试，然后就是一遍又一遍对着几千条日志debug，找出一个又一个问题，增改几行代码……最后终于是通过了测试，但是代码已经成屎山了，搞的自己也看不太懂。到优化代码的时候，很快就发现原来是自己的方案想错了：用的这个方案会带来很多边界情况，而这些边界情况难处理、难debug，导致了多个测试都过不去；而若是一开始就选用好的方案，压根就不会出现这么多恶心的边界情况，也就很容易debug了。以后要提醒自己写代码不能只往后写，还要时不时向前看，及时重构方案，防患于未然。\n一次，魏文王问扁鹊说：“你们家兄弟三人，都精于医术，到底哪一位最好呢？”扁鹊答：“长兄最好，中兄次之，我最差。”文王又问：“那么为什么你最出名呢？”扁鹊答：“长兄治病，是治病于病情发作之前，由于一般人不知道他事先能铲除病因，所以他的名气无法传出去；中兄治病，是治病于病情初起时，一般人以为他只能治轻微的小病，所以他的名气只及本乡里；而我是治病于病情严重之时，一般人都看到我在经脉上穿针管放血，在皮肤上敷药等大手术，所以以为我的医术高明，名气因此响遍全国。”\n","wordCount":"619","inLanguage":"en","datePublished":"2022-11-17T00:00:00Z","dateModified":"2022-11-17T00:00:00Z","author":{"@type":"Person","name":"wsmbsbbz"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wsmbsbbz.github.io/posts/mit6.824-lab2b-log/"},"publisher":{"@type":"Organization","name":"wsmbsbbz.github.io","logo":{"@type":"ImageObject","url":"https://wsmbsbbz.github.io/img/logo.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wsmbsbbz.github.io accesskey=h title="wsmbsbbz.github.io (Alt + H)"><img src=https://wsmbsbbz.github.io/img/logo.ico alt aria-label=logo height=35>wsmbsbbz.github.io</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wsmbsbbz.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://wsmbsbbz.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://github.com/wsmbsbbz title=github.com><span>github.com</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>MIT6.824 Raft-Log实验记录</h1><div class=post-meta><span title='2022-11-17 00:00:00 +0000 UTC'>November 17, 2022</span>&nbsp;·&nbsp;wsmbsbbz&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/mit6.824-lab2b-log.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#实验分析>实验分析</a></li><li><a href=#结构设计>结构设计</a><ul><li><a href=#logentry>logEntry</a></li><li><a href=#raft>Raft</a></li><li><a href=#requestvoteargs>RequestVoteArgs</a></li><li><a href=#appendentriesargs>AppendEntriesArgs</a></li></ul></li><li><a href=#逻辑设计>逻辑设计</a><ul><li><a href=#committer>committer</a></li><li><a href=#start>Start</a></li><li><a href=#sendheartbeat>sendHeartbeat</a></li><li><a href=#appendentries>AppendEntries</a></li></ul></li><li><a href=#踩坑>踩坑</a></li><li><a href=#优化空间>优化空间</a></li><li><a href=#总结>总结</a><ul><li><a href=#收获>收获</a></li><li><a href=#教训>教训</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>Lab用时：14.5小时</p></blockquote><p><img loading=lazy src=/image/mit6.824-lab2b-log/1.jpg alt></p><h2 id=实验分析>实验分析<a hidden class=anchor aria-hidden=true href=#实验分析>#</a></h2><p>本实验要让<code>Raft</code>在在上一个<a href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/>Leader Election</a>的基础上，对<code>clients</code>的请求做出响应，接受<code>clients</code>的<code>command</code>，并在<code>command</code>被安全committed后响应<code>clients</code>。</p><p><a href=https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf>Raft paper</a>中的Figure 2仍然是最有价值的参照：</p><p><img loading=lazy src=/image/mit6.824-lab2b-log/2.png alt></p><p>我们需要实现：</p><ol><li>leader要能够把<code>Start</code>方法的<code>command</code>参数<code>append</code>到自身的log中，然后通过<code>AppendEntries RPC</code>把log发送给别的peers。</li><li>followers不能仅把<code>AppendEntries RPC</code>当作heartbeat，还要把<code>RPC</code>参数和自己的log比较，并在恰当的时机修改自身的log相关的字段，并返回Figure 2要求的reply。</li><li>注意上一个Leader Election lab中并没有要求实现paper中5.4.1章节的Election Restriction，我们还需要在<code>RequestVote RPC handler</code>中实现。</li></ol><h2 id=结构设计>结构设计<a hidden class=anchor aria-hidden=true href=#结构设计>#</a></h2><p>这里只写相较于<a href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/>Leader Election</a>需要增添或更改的部分。</p><h3 id=logentry>logEntry<a hidden class=anchor aria-hidden=true href=#logentry>#</a></h3><p>除了必须的<code>Term</code>和<code>Command</code>字段外，我也把log的Index写入了<code>logEntry</code>中，这样代码会更加简洁，详见我后面踩坑部分的解释。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>logEntry</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Index</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>Term</span>    <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>Command</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=raft>Raft<a hidden class=anchor aria-hidden=true href=#raft>#</a></h3><p>除了<a href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/>Leader Election</a>中已经实现的字段外，对于这个lab，我加上了这些字段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Raft</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span> <span class=p>[]</span><span class=nx>logEntry</span> <span class=c1>// 自身的log条目
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>commitIndex</span> <span class=kt>int</span> <span class=c1>// 最近一次commit的log的index，要保证这个字段只能单增
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sequreCommit</span> <span class=kt>int</span> <span class=c1>// 可以安全commit的log的index
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// paper中nextIndex字段我没有用到，实测只需要matchIndex就足够了，维护nextIndex的状态反而会使代码逻辑更加复杂
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>matchIndex</span> <span class=p>[]</span><span class=kt>int</span> <span class=c1>// 长度为peers的数量，表明当前peer和别的peers匹配成功的最大log index
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>applyCh</span> <span class=kd>chan</span> <span class=nx>ApplyMsg</span> <span class=c1>// 每当commitIndex递增时，就应该向applyCh发送一个ApplyMsg，以供Tester测试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=requestvoteargs>RequestVoteArgs<a hidden class=anchor aria-hidden=true href=#requestvoteargs>#</a></h3><p>Leader Election只需要<code>Term</code>和<code>CandidateId</code>，若要实现5.4.1的Election Restriction，还需要加上<code>LastLogIndex</code>和<code>LastLogTerm</code>两个字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>RequestVoteArgs</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Term</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>CandidateId</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>LastLogIndex</span> <span class=kt>int</span> <span class=c1>// 发送RequestVote的peer的最新的log的index
</span></span></span><span class=line><span class=cl><span class=c1></span> 	<span class=nx>LastLogTerm</span> <span class=kt>int</span> <span class=c1>// 发送RequestVote的peer的最新的log的term
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=appendentriesargs>AppendEntriesArgs<a hidden class=anchor aria-hidden=true href=#appendentriesargs>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>AppendEntriesArgs</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Term</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>LeaderId</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>PrevLogIndex</span> <span class=kt>int</span> <span class=c1>// AppendEntries假定的此peer拥有的最新的log的index
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PrevLogTerm</span> <span class=kt>int</span> <span class=c1>// AppendEntries假定的此peer拥有的最新的log的term
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Entries</span> <span class=p>[]</span><span class=nx>logEntry</span> <span class=c1>// 需要append的logEntry
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>LeaderCommit</span> <span class=kt>int</span> <span class=c1>// RPC发起者的secureCommit的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=逻辑设计>逻辑设计<a hidden class=anchor aria-hidden=true href=#逻辑设计>#</a></h2><p>这一部分的lab涉及很多log的更新，debug难度比Leader Election难很多。而且需要精心设计、分析一些机制的实现思路，否则非常容易栽到某写edge cases，然后坠入debug的深渊一去不返……如果能选定合适的实现思路，那代码逻辑并不难写，在<a href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/>Leader Election</a>的代码基础上修修补补即可。</p><h3 id=committer>committer<a hidden class=anchor aria-hidden=true href=#committer>#</a></h3><p>效仿之前<a href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/>Leader Election</a>的<code>ticker()</code>和<code>beater()</code>，我又写了一个<code>committer()</code>，用来递增<code>commitIndex</code>并向<code>applyCh</code>发送<code>ApplyMsg</code>。对于leader，还要更新<code>secureCommit</code>的值，这里我参考了别人的实现思路，对<code>matchIndex</code>排序，把中间值设定为<code>secureCommit</code>。也原子化绑定了<code>commitIndex</code>和发送<code>ApplyMsg</code>操作、保证了<code>commitIndex</code>是单增的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>committer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>killed</span><span class=p>()</span> <span class=o>==</span> <span class=kc>false</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=o>==</span> <span class=nx>Leader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>commitNums</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nb>copy</span><span class=p>(</span><span class=nx>commitNums</span><span class=p>,</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>matchIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>commitNums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>commitIndex</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>secureCommit</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>secureCommit</span> <span class=p>=</span> <span class=nx>commitNums</span><span class=p>[</span><span class=nx>n</span><span class=o>/</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>commitIndex</span> <span class=p>&lt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>secureCommit</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>commitIndex</span><span class=o>++</span>
</span></span><span class=line><span class=cl>			<span class=nx>applyMsg</span> <span class=o>:=</span> <span class=nx>ApplyMsg</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>CommandValid</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>Command</span><span class=p>:</span>      <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nx>rf</span><span class=p>.</span><span class=nx>commitIndex</span><span class=p>].</span><span class=nx>Command</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>CommandIndex</span><span class=p>:</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nx>rf</span><span class=p>.</span><span class=nx>commitIndex</span><span class=p>].</span><span class=nx>Index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>applyCh</span> <span class=o>&lt;-</span> <span class=nx>applyMsg</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>timerLoop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=start>Start<a hidden class=anchor aria-hidden=true href=#start>#</a></h3><p><code>Start()</code>方法负责把<code>tester/clients</code>的<code>command</code>添加到自身的log中，然后直接return。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>Start</span><span class=p>(</span><span class=nx>command</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Your code here (2B).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span><span class=p>,</span> <span class=nx>term</span><span class=p>,</span> <span class=nx>isLeader</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nx>Index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span><span class=p>,</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=o>==</span> <span class=nx>Leader</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=o>!=</span> <span class=nx>Leader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>term</span><span class=p>,</span> <span class=nx>isLeader</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>log</span> <span class=o>:=</span> <span class=nx>logEntry</span><span class=p>{</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nx>Index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span><span class=p>,</span> <span class=nx>command</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>log</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>,</span> <span class=nx>log</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>term</span><span class=p>,</span> <span class=nx>isLeader</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个时候读者可能会意识到一个问题，就是我们什么时候向peers发送包含log信息的<code>AppendEntries RPC</code>呢？</p><p><a href=https://thesquareplanet.com/blog/students-guide-to-raft/>Students&rsquo; Guide to Raft</a>中明确说明了，<strong><code>heartbeat</code>和一般的含有log信息的<code>AppendEntries</code>不仅仅是都通过<code>AppendEntries RPC</code>来调用，同样需要完全按照<code>AppendEntries RPC handler</code>的流程对待</strong>。</p><blockquote><p>Many of our students assumed that heartbeats were somehow “special”; that when a peer receives a heartbeat, it should treat it differently from a non-heartbeat <code>AppendEntries</code> RPC. In particular, many would simply reset their election timer when they received a heartbeat, and then return success, without performing any of the checks specified in Figure 2. This is <em>extremely dangerous</em>.</p></blockquote><p>但我没有按照guide把heartbeat的log长度设为0，而是做的更极端了一点：直接让heartbeat也能带有<code>logEntry</code>。这样能在candidate成为leader之后，立即把自身的所有log发送给别的peers，然后根据响应更新<code>matchIndex</code>，再之后网络连接稳定的情况下，followers和leader的log能保持一致，此时的heartbeat中不包含<code>logEntry</code>，<code>AppendEntries RPC handler</code>也就不会更新自身的log了。实现的关键在于<code>sendHeartbeat</code>和<code>AppendEntries</code>。</p><h3 id=sendheartbeat>sendHeartbeat<a hidden class=anchor aria-hidden=true href=#sendheartbeat>#</a></h3><p><code>sendHeartbeat()</code>根据<code>matchIndex</code>对所有peers(<strong>包括leader自身</strong>)发送带有合适<code>logEntry</code>的<code>AppendEntries RPC</code>请求，并在<code>reply.Success == true</code>时递增<code>matchIndex</code>。</p><p>注意这里不能直接使用<code>matchIndex[i] += len(args.Entries)</code>，否则若出现<strong>RPC交错</strong>的情况，<code>matchIndex</code>的值可能会减少，就不符合<code>matchIndex</code>的单增性质；也不能直接用<code>matchIndex[i] = args.PrevLogIndex+len(args.Entries)</code>，在<strong>RPC交错</strong>的时候也可能导致<code>matchIndex</code>的值减少（不过在lab测试中没有测试这种情况）。</p><blockquote><p>注：我这里所说的RPC交错指的是：先通过RPC调用发出请求A再发出B，但是先收到B的响应再收到A的响应。但我们不能用lock序列化发送RPC并等待接受响应，这样性能损耗太大，所以只能通过类似的单增性质来保证过时的RPC响应不影响程序的正确性。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// NOTE: protocol: 必须已经hold rf.mu,再调用此方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>sendHeartbeats</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>args</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>AppendEntriesArgs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Term</span><span class=p>:</span>         <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>LeaderId</span><span class=p>:</span>     <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>PrevLogIndex</span><span class=p>:</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>matchIndex</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span>
</span></span><span class=line><span class=cl>			<span class=nx>PrevLogTerm</span><span class=p>:</span>  <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nx>rf</span><span class=p>.</span><span class=nx>matchIndex</span><span class=p>[</span><span class=nx>i</span><span class=p>]].</span><span class=nx>Term</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>Entries</span><span class=p>:</span>      <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nx>rf</span><span class=p>.</span><span class=nx>matchIndex</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>:],</span>
</span></span><span class=line><span class=cl>			<span class=nx>LeaderCommit</span><span class=p>:</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>secureCommit</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>AppendEntriesReply</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nf>sendAppendEntries</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>rf</span><span class=p>.</span><span class=nf>coverTerm</span><span class=p>(</span><span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Success</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>rf</span><span class=p>.</span><span class=nx>matchIndex</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nf>max</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>matchIndex</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogIndex</span><span class=o>+</span><span class=nb>len</span><span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>Entries</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=appendentries>AppendEntries<a hidden class=anchor aria-hidden=true href=#appendentries>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>AppendEntries</span><span class=p>(</span><span class=nx>args</span> <span class=o>*</span><span class=nx>AppendEntriesArgs</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=nx>AppendEntriesReply</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Rules for All Servers:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// NOTE: rule 1 has been implemented in committer
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 2. if args.Term &gt; rf.currentTerm, convert to follower
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nf>coverTerm</span><span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>Term</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Receiver implementation:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 1. reply false if term &lt; currentTerm
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&lt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Success</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 2. reply false if log doesn&#39;t contain an entry at prevLogIndex whose term
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// matches prevLogTerm
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>lastLog</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogIndex</span> <span class=p>&gt;</span> <span class=nx>lastLog</span><span class=p>.</span><span class=nx>Index</span> <span class=o>||</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogIndex</span><span class=p>].</span><span class=nx>Term</span> <span class=o>!=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Success</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 3. If an existing entry conflicts with a new one (same index but different
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// terms), delete the existing entry and all that follow it ($5.3)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kd>var</span> <span class=nx>i</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>Entries</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogIndex</span><span class=o>+</span><span class=mi>1</span><span class=o>+</span><span class=nx>i</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nf>checkLogEqual</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogIndex</span><span class=o>+</span><span class=mi>1</span><span class=o>+</span><span class=nx>i</span><span class=p>],</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Entries</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>log</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[:</span><span class=nx>args</span><span class=p>.</span><span class=nx>PrevLogIndex</span><span class=o>+</span><span class=mi>1</span><span class=o>+</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 4. Append any new entries not already in the log
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>log</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>,</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Entries</span><span class=p>[</span><span class=nx>i</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 5. If leaderCommit &gt; commitIndex, set commitIndex = min(
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// leaderCommit, index of last new entry)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>secureCommit</span> <span class=p>=</span> <span class=nf>min</span><span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>LeaderCommit</span><span class=p>,</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>log</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nx>Index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>Success</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nf>tickerReset</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>AppendEntries</code>按照Figure 2的要求来即可。</p><h2 id=踩坑>踩坑<a hidden class=anchor aria-hidden=true href=#踩坑>#</a></h2><p>这次lab踩坑较多：</p><ol><li>一开始我的<code>logEntry</code>结构中没有设定<code>Index</code>字段，是用数组下标来表示index的，就有很多很难处理的边界情况。后来加了<code>Index</code>字段之后，也在Raft启动时直接增添一个<code>Index</code>为0的空log，保证log的<code>Index</code>和数组的下标相同，这应该也能简化后面log impaction lab的代码。</li><li>一开始没有想到专门设一个<code>committer</code>的思路，也没能把heartbeat和带<code>logEntry</code>的<code>AppendEntries</code>完全画等号，导致代码逻辑冗杂混乱。</li><li>虽然<a href=https://thesquareplanet.com/blog/students-guide-to-raft/>Students&rsquo; Guide to Raft</a>中明确说明了<code>nextIndex</code>和<code>matchIndex</code>是两个不同的状态，不能简单使用<code>matchIndex + 1</code>来表示<code>nextIndex</code>，但我实际发现在我的代码版本中<code>nextIndex</code>字段就没有存在的必要，只需要保证每个peer的<code>matchIndex</code>中每个位置都从0开始单增，就足以保证Raft能正常推进。不过缺点是在leader更替之后，新leader还要让<code>matchIndex</code>从0开始递增，会导致RPC参数体积过大，有较大网络流量。在完成log impaction lab之后应该能有效解决这个问题。</li><li>我本来在发送和接受RPC响应的地方写了很多检查<code>state</code>状态有没有改变的代码，想借此处理RPC发送期间<code>state</code>改变的情况（比如：leader在发送<code>AppendEntries</code>请求后退位，成为follower，那就不应该处理RPC的响应了）。但paper和lab要求中没有说要实现这些，实际上也只需保证某些字段的更新限制(如单增)就能保证RPC处理的安全性。</li><li><code>Start</code>方法应该尽快响应，在goroutine中处理log replication、commit的逻辑。不需要在<code>Start</code>中主动发起<code>AppendEntries RPC</code>请求，等待后台长时间运行的<code>beater</code>和<code>committer</code>处理即可。</li><li>起初在<code>sendHeartbeat</code>或者<code>AppendEntries</code>中写了一些检测RPC请求是否是heartbeat的代码，后来才意识到可以让这两个请求完全等价。</li><li>起初我用<code>sync.Cond</code>计算<code>AppendEntries RPC</code>响应的<code>successCnt</code>，在<code>successCnt</code>超过半数时commit。后来参考别人的思路改用排序<code>commitIndex</code>取中值的写法，很大程度上简化了代码逻辑，在通常仅有<strong>几台</strong>的Raft集群中也几乎没有什么排序代价。</li><li>Raft的paper字字珠玑，我一开始没有理解log是否up-to-date的含意：需要检测<code>args.LastLogTerm &lt; curLastLogTerm</code>和<code>args.LastLogTerm == curLastLogTerm && args.LastLogIndex &lt; curLastLogIndex</code>两种情况。</li><li>在发送和接受处理RPC时，没必要对leader自身区别对待，即leader可以用<strong>尽可能少的特权</strong>，只更新维持Raft状态推进的必要状态，其余的状态通过自己对自己发送RPC来更新，能简化代码。</li></ol><h2 id=优化空间>优化空间<a hidden class=anchor aria-hidden=true href=#优化空间>#</a></h2><p>还真不知道。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>最终的成品代码我比较满意，<code>ticker</code>、<code>beater</code>、<code>committer</code>这三个长时间在goroutine中运行的三个方法是非常好的一层抽象：Raft状态机在<code>Start</code>方法中更新自己的<code>log</code>状态，<code>ticker</code>更新<code>state</code>状态，<code>beater</code>联系别的peers更新他们的<code>log</code>状态，<code>committer</code>更新自己的<code>commitIndex</code>状态，相互之间有很清晰的分工和隔离，整体程序框架和代码逻辑都很清晰。</p><h3 id=收获>收获<a hidden class=anchor aria-hidden=true href=#收获>#</a></h3><p>有了上次<a href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/>Leader Election</a>的教训，这次没有在lock上再翻车，对lock的运用要熟练很多。</p><p>这个lab不仅要处理本地程序的代码并发，还要处理网络中RPC请求、响应的并发。而对RPC加lock绝对是得不偿失的，于是通过对属性的更新设限制来保证RPC并发的安全性。这确实是我以前从未见过的处理方式，涨见识了。</p><h3 id=教训>教训<a hidden class=anchor aria-hidden=true href=#教训>#</a></h3><p>感觉这次写代码还是有点操之过急了，debug了非常久，下个lab可以尝试把整个完整方案从头到尾写完整，再分析每一个步骤可能带来的问题，仔细分析多个替代方案之后再开始写代码。</p><p>这好几次写lab都是写好代码后跑不过测试，然后就是一遍又一遍对着几千条日志debug，找出一个又一个问题，增改几行代码……最后终于是通过了测试，但是代码已经成屎山了，搞的自己也看不太懂。到优化代码的时候，很快就发现原来是自己的方案想错了：用的这个方案会带来很多边界情况，而这些边界情况难处理、难debug，导致了多个测试都过不去；而若是一开始就选用好的方案，压根就不会出现这么多恶心的边界情况，也就很容易debug了。以后要提醒自己写代码不能只往后写，还要时不时向前看，及时重构方案，防患于未然。</p><blockquote><p>一次，魏文王问扁鹊说：“你们家兄弟三人，都精于医术，到底哪一位最好呢？”扁鹊答：“长兄最好，中兄次之，我最差。”文王又问：“那么为什么你最出名呢？”扁鹊答：“长兄治病，是治病于病情发作之前，由于一般人不知道他事先能铲除病因，所以他的名气无法传出去；中兄治病，是治病于病情初起时，一般人以为他只能治轻微的小病，所以他的名气只及本乡里；而我是治病于病情严重之时，一般人都看到我在经脉上穿针管放血，在皮肤上敷药等大手术，所以以为我的医术高明，名气因此响遍全国。”</p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://wsmbsbbz.github.io/posts/mit6.824-lab2a-leader-election/><span class=title>Next »</span><br><span>MIT6.824 Raft-Leader Election实验记录</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wsmbsbbz.github.io>wsmbsbbz.github.io</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>